## 2.1.1 네트워크 애플리케이션의 구조
애플리케이션 구조는 애플리케이션 개발자에 의해 설계되고 애플리케이션이 다양한 종단 시스템에서 어떻게 조직되어야 하는지를 지시한다. 일반적으로 개발자는 '클라이언트-서버 구조' 혹은 'P2P 구조' 중의 하나로 작성한다.

### 클라이언트 - 서버 구조(client-server architecture)
<p align="center">
  <img src="image1.png" alt="인터넷 이미지" width="300"/> 
</p>
항상 켜져있는 호스트를 서버라고 부르고 이 서버는 클라이언트라는 다른 많은 호스트의 요청을 받는다.
웹 서버가 클라이언트로부터 객체를 요청받으면 웹 서버는 클라이언트로 요청된 객체를 보내어 응답한다.

주목할 점은, 클라이언트들은 서로 직접적으로 통신하지 않는다. 생각해보면 2개의 브라우저가 서로 직접적으로 통신하지는 않는다!
또 다른 특징은 서버가 고정 IP 주소라는 잘 알려진 주소를 갖는다는 것이다.

클라이언트와는 다르게 서버는 항상 동작하므로 클라이언트는 서버 주소로 패킷을 보내서 항상 서버에 연결할 수 있다.

적은 수의 클라이언트가 서버에 연결할 때에는 서버가 모든 클라이언트의 요청에 대해 응답해주는 것이 가능하겠지만, 실제 상황을 생각해보면 셀 수 없이 많은 클라이언트가 하나의 서버에 요청을 보내면 그 서버가 모든 클라이언트에 대해 응답하기란 불가능하다.
그래서 우리가 알고 있는 구글이나, 아마존, 알리바바, 페이스북과 같은 인기 있는 서비스들은 하나 이상의 데이터 센터를 사용한다.

### P2P(peer-to-peer) 구조
<p align="center">
  <img src="image2.png" alt="인터넷 이미지" width="300"/> 
</p>
P2P 구조는 켜져 있는 서버에 최소로 의존하거나 혹은 전혀 의존하지 않는다.
대신에 피어라고 하는 호스트 쌍이 '서로 직접' 통신하도록 한다. 여기서의 피어는 사용자들이 제어하는 데스트톱과 랩톱을 의미한다.
통신하는 과정에 특정 서버를 통하지 않고, 피어가 통신하기 때문에 peer-to-peer, P2P 라고 한다.
비트토렌트와 같은 파일공유, 스카이프와 같은 인터넷 전화 및 비디오 컨퍼런스 같이 트래픽 집중적인 애플리케이션들이 P2P 의 대표적인 예이다.
(어떤 어플리케이션들은 클라이언트-서버 와 P2P 요소들을 결합해서 사용하기도 한다. 사용자의 IP 를 추적할 때에는 클라이언트-서버 구조를, 사용자 간 메세지는 P2P 구조를 이용하는 식이다.)

P2P 구조의 가장 주목할 만한 특성 중 하나는 **자가 확장성(self-scalability)** 이다. 
P2P 에서는 모든 사용자가 '소비자'이자 '공급자'의 역할을 한다.
예시를 들어보자. 친구 A,B,C 가 있다고 할 때, B는 A 로 부터 '영화1' 이라는 파일을 받았다. 그러면 이제 A 뿐만 아니라 B 도 C 에게 '영화1'이라는 파일을 제공할 수 있는 공급자의 역할도 할 수 있게 되는 것이다.
클라이언트-서버 구조와는 다르게 상당한 서버 기반 구조와 서버 대역폭을 요구하지 않기에 비용 효율적이다.
그치만, 고도의 분산 구조 특성으로 인해 보안, 성능, 신뢰성에 대한 문제점 또한 가지고 있다.

## 2.1.2 프로세스 간 통신
### 클라이언트와 서버 프로세스
운영체제 용어에서 실제로 '통신'을 하는 것은 프로그램이 아니라 **프로세스** 이다. 여기서 프로세스는 종단 시스템에서 실행되는 프로그램을 의미한다.
네트워크 애플리케이션은 네트워크에서 서로 메시지를 보내는 두 프로세스로 구성이 된다. 예를 들어, 브라우저가 클라이언트 - 웹서버가 서버 라고 이름 붙이고, P2P 구조에선 파일을 내려주는 클라이언트를 서버 - 파일을 내려받은 클라이언트를 클라이언트 라고 부를 수 있겠다.

즉, 두 프로세스 간의 통신 세션에서 통신을 '초기화'(다른 프로세스와 세션을 시작하려고 접속을 초기화)하는 프로세스를 **클라이언트**라고 하고,
세션을 시작하기 위해 접속을 '기다리는' 프로세스를 **서버**라고 한다.

### 프로세스와 컴퓨터 네트워크 사이의 인터페이스
네트워크 통신을 하려면 하나의 프로세스에서 다른 프로세스로 메시지를 보내야하는데, 프로세스는 **소켓(socket)**을 통해 네트워크로 메시지를 주고받는다.
예시를 들어보자. 프로세스는 집, 소켓을 출입문이라고 하면 내가 우리집에서 친구집으로 가려면 우리집 출입문을 열고 나가서 친구집 출입문을 통해 친구집으로 들어가야한다.
메시지도 같은 방법으로 전달된다.

<p align="center">
  <img src="image3.png" alt="인터넷 이미지" width="500"/> 
</p>

그림에서 볼 수 있듯이 소켓은 호스트 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스이다. 또한, 네트워크 애플리케이션이 인터넷에 만든 프로그래밍 인터페이스이므로
API(Application Programming Interface) 라고도 한다.
애플리케이션 개발자가 트랜스포트 프로토콜을 선택하면 애플리케이션은 그 프로토콜이 제공하는 전송 서비스를 사용하여 구성된다.

### 프로세스 주소 배정
내가 친구집을 찾아가기 위해선 친구집의 주소를 알고 있어야한다. 네트워크 상에서도 마찬가지로 프로세스가 다른 프로세스로 패킷을 보내기 위해서는 수신 프로세스가 주소를 가지고 있어야한다.
1. 호스트의 주소
2. 그 목적지 호스트 내의 수신 프로세스를 명시하는 식별자

이렇게 2가지 정보가 필요하게 된다.

인터넷에서 호스트는 **IP 주소**로 식별된다. 이 정보로는 호스트를 유일하게 식별해주기만 한다.
예를 들어, IP 주소로는 광진구에 위치한 건국대학교 라는 것만 식별할 수 있을 뿐이지, 여기서 근무하는 김아무개 교수님을 찾아낼 순 없다는 의미이다.
그래서, 정확한 수신 프로세스를 찾기위해 **포트 번호**를 사용한다. 공과대학 컴퓨터공학부 컴퓨터네트워크(과목번호 1234)를 강의하는 김아무개 교수 를 의미한다.
이보다 어떻게 정확할 수 있겠는가!

## 2.1.3 애플리케이션이 이용 가능한 트랜스포트 서비스
### 신뢰적 데이터 전송
패킷은 라우터의 버퍼에서 오버플로우 되거나, 패킷의 비트가 잘못되면 호스트 혹은 라우터에 의해 버려질 수 있다. 그런데, 재무 애플리케이션처럼 경우에 따라 데이터 손실이 위험한 결과를 
가져올 수 있다. 따라서 프로토콜이 보장된 데이터 전송 서비스를 제공한다면 이를 **신회적 데이터 전송**을 제공한다고 한다. 트랜스포트 프로토콜이 이 서비스를 제공할 때, 송신 프로세스는 데이터를
소켓으로 보내고 그 데이터가 오류 없이 수신 프로세스에 도착할 것이라는 확신을 갖게 된다.

반대로, 트랜스포트 계층 프로토콜이 신뢰적 데이터 전송을 제공하지 않을 때에는 송신 프로세스가 보낸 데이터는 수신
프로세스에 전혀 도착하지 않을 수 있다.

### 처리량
1장에서 가용한 처리율의 개념에 대해 알아보았는데, 너무나 당연하게 다른 세션들이 네트워크 경로를 따라 대역폭을 공유하게 되고, 이 세션들이
생겼다 없어졌다 하기 때문에 가용한 처리율은 시간에 따라 변동된다. 이런 불안정한 상황 때문에, 어떤 애플리케이션은 "나는 최소한 이 정도 속도는 꼭 필요해!"라고 요구할 수 있으며,
트랜스포트 프로토콜이 그 요청을 들어주고, 요구된 속도를 보장해줄 수 있다. 

처리율이 원하는 요구사항 보다 낮아지면 안되는 애플리케이션을 **대역폭 민감 애플리케이션**이라고 부르고, 가용한 처리율을 많으면 많은 대로 적으면 적은 대로 이용해도 문제가 없는 애플리케이션을
**탄력적 애플리케이션**이라고 한다.

### 시간
트랜스포트 계층 프로토콜은 또한 시간 보장을 제공한다. 예를 들면, 송신자가 소켓으로 내보내는 모든 비트가 수신자의 소켓에 100 msec 내에 도착하도록 하는 것이다. 
이러한 특성은 상호 작용 실시간 애플리케이션에 요구되는 조건들이다.

### 보안
애플리케이션에 하나 이상의 보안 서비스도 제공해준다. 예를 들어, 송신 호스트에서 트랜스포트 프로토콜은 송신 프로세스가 전송하는 모든 데이터를 암호화할 수 있고 
수신 호스트에서 트랜스포트 프로토콜은 그 데이터를 수신 프로세스로 전달하기 전에 데이터의 암호를 해독할 수 있다.

## 2.1.4 인터넷 전송 프로토콜이 제공하는 서비스
인터넷은 애플리케이션에게 2개의 전송 프로토콜, 즉 UDP(User Datagram Protocol) 와 TCP(Transmission Control Protocol)를 제공한다.

### TCP 서비스
- 연결 지향형 서비스 : 애플리케이션 계층 메시지를 전송하기 전에 TCP는 클라이언트와 서버가 서로 전송 제어 정보를 교환하도록 하는데, 이 과정을 핸드쉐이킹 과정이라고 하고 양측에 '곧 패킷이 도달할 것이니 준비를 해!'라고 말하는 것과 같다.
핸드쉐이킹 단계를 지나면 TCP 연결이 두 프로세스의 소켓 사이에 존재한다고 말할 수 있다. 연결된 서로가 동시에 메시지를 보낼 수 있기에 **전이중(full-duplex) 연결**이라고 한다. 메시지 전송을 마치면 연결을 끊어야한다.


- 신뢰적인 데이터 전송 서비스 : 모든 데이터를 오류 없이, 올바른 순서로 전달하기 위해 TCP 에 의존하는데, TCP 는 애플리케이션의 한쪽이 데이터를 전송하면 그 데이터를 손실하거나 중복되지 않게 전달하는 역할을 한다.

### UDP 서비스
최소의 서비스 모델을 가진 간단한 전송 프로토콜이다.

**비연결성**이므로 두 프로세스가 통신을 하기 전에 핸드쉐이킹을 하지 않고, **비신뢰적**인 전송 서비스를 제공하기 때문에 소켓으로 메시지를 보내도 그 메시지가 수신 소켓에 도착하는 것을 보장하지 않는다. 도착하더라도 순서가 뒤바뀔 수도 있다. 
TCP 와는 다르게 UDP 는 혼잡제어 방식을 포함하지 않기 때문에 송신 측은 데이터를 원하는 속도로 하위 계층으로 보낼 수 있다.

## 2.1.5 애플리케이션 계층 프로토콜

